#include<Arduino.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>
#include <freertos/queue.h> // thread-safe queue used to dispatch updates to the main thread
#include <atomic>
#include <Ticker.h>

/*
 * General info + examples at https://docs.espressif.com/projects/arduino-esp32/en/latest/api/ble.html
 * Complete list of examples: https://github.com/espressif/arduino-esp32/tree/master/libraries/BLE/examples
 */

/*
 * TODO: add authentication mechanism
 */

#define SERVICE_UUID "6e400001-b5a3-f393-e0a9-e50e24dcca9e"
// characteristic writable by the client (Android app): App -> esp32
#define CHARACTERISTIC_UUID_RX "6e400002-b5a3-f393-e0a9-e50e24dcca9e"
// characteristic writable by the server/pheriperal (esp32): esp32 -> App
#define CHARACTERISTIC_UUID_TX "6e400003-b5a3-f393-e0a9-e50e24dcca9e"

#define QUEUE_SZ 10

BLEServer* pServer = NULL;
BLECharacteristic* pRxCharacteristic = NULL;
BLECharacteristic* pTxCharacteristic = NULL;

std::atomic<bool> deviceConnected(false);
bool deviceBonded = false;

QueueHandle_t msgQueue = xQueueCreate(QUEUE_SZ, sizeof(const String));

class MyServerCallbacks: public BLEServerCallbacks {
  void onConnect(BLEServer* pServer) {
    Serial.println("Received connection event");
    deviceConnected = true;
    deviceBonded = false;
  };

  void onDisconnect(BLEServer* pServer) {
    Serial.println("Received disconnection event");
    deviceConnected = false;
    deviceBonded = false;
  }
};

class MyCallbacks : public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic *pCharacteristic) {
    String rxValue = String(pCharacteristic->getValue().c_str());

    Serial.println("Received value: " + rxValue);

    if(!deviceBonded) {
      Serial.println("received message: " + rxValue + " but not authenticated");
      return;
    }

    if (xQueueSend(msgQueue, &rxValue, portMAX_DELAY) != pdPASS) {
      Serial.println("QUEUE is full!!!!");
    }
  }
};

class MySecurity : public BLESecurityCallbacks {
  private:
    bool pairing = false;
    uint32_t passKey = 0;

  public:
    
    // the esp32 is asked to return the password displayed by the android app.
    // It is useful if the android displays the passkey and the esp32 inserts it, but in our case it will be the other way around.
    uint32_t onPassKeyRequest() {
      Serial.println("Request to enter the passkey shown by the peer device");
      pairing = true;
      return 123456;
    }

    // responds to the android app that is asking the esp32 to display the passkey that will be entered by the user. 
    // The passkey is automatically generated by the BLE stack and passed to the method when a notify arrives from the other device (e.g. the smartphone)
    void onPassKeyNotify(uint32_t pass_key) {
      Serial.printf("Passkey Notified to enter in the Android app: %d\n", pass_key);
      pairing = true;
      passKey = pass_key;
    }

    // return true whether the user's input to the device matches pass_key, not used for Passkey Enter mode.   
    bool onConfirmPIN(uint32_t pass_key) {
      Serial.printf("Confirming Passkey: %d\n", pass_key);

      bool isValid = pass_key == passKey;

      if(!isValid) {
        Serial.println("Mismatch between the passed key and the generated one");
      }
      return isValid;
    }

    // called in response to the peer (application) trying to establish pairing.
    // For example, by clicking the "Bond" button in the nRFConnect app
    bool onSecurityRequest() {
      Serial.println("Security request received.");
      return true;
    }

    // function called when the authentication process completes either successfully or not (e.g. timer expires before the user inserts the passkey) 
    void onAuthenticationComplete(esp_ble_auth_cmpl_t cmpl) {
      if (cmpl.success) {
        Serial.println("Authentication Success. Device bonded.");
        deviceBonded = true;
      } else {
        if (!pairing) {
          Serial.printf("Strange behaviour: failing happens before pairing even started (not set to true)\n");
        }
        Serial.printf("Authentication failed\n");
        Serial.printf("\t\t-code: 0x%02X\n", cmpl.fail_reason);
        Serial.printf("\t\t-address: %d\n", cmpl.addr_type);
        Serial.printf("\t\t-authentication mode: %d\n", cmpl.auth_mode);
        deviceBonded = false;
      }
      pairing = false;
    }
};


Ticker randomEvent;

void sendMsg() {
  if (deviceConnected) {
    String msg = "Testing";
    Serial.println("Sending msg: " + msg);
    pTxCharacteristic->setValue(std::string(msg.c_str()));
    pTxCharacteristic->indicate();
    randomEvent.once(5,sendMsg);
  }
}


void advertise(BLEServer* pServer);

void setupBonding() {
  esp_ble_auth_req_t auth_req = ESP_LE_AUTH_REQ_SC_MITM_BOND;
  esp_ble_io_cap_t iocap = ESP_IO_CAP_OUT;          
  uint8_t key_size = 16;     
  uint8_t init_key = ESP_BLE_ENC_KEY_MASK | ESP_BLE_ID_KEY_MASK;
  uint8_t rsp_key = ESP_BLE_ENC_KEY_MASK | ESP_BLE_ID_KEY_MASK;
  uint8_t auth_option = ESP_BLE_ONLY_ACCEPT_SPECIFIED_AUTH_DISABLE;
  esp_ble_gap_set_security_param(ESP_BLE_SM_AUTHEN_REQ_MODE, &auth_req, sizeof(uint8_t));
  esp_ble_gap_set_security_param(ESP_BLE_SM_IOCAP_MODE, &iocap, sizeof(uint8_t));
  esp_ble_gap_set_security_param(ESP_BLE_SM_MAX_KEY_SIZE, &key_size, sizeof(uint8_t));
  esp_ble_gap_set_security_param(ESP_BLE_SM_ONLY_ACCEPT_SPECIFIED_SEC_AUTH, &auth_option, sizeof(uint8_t));
  esp_ble_gap_set_security_param(ESP_BLE_SM_SET_INIT_KEY, &init_key, sizeof(uint8_t));
  esp_ble_gap_set_security_param(ESP_BLE_SM_SET_RSP_KEY, &rsp_key, sizeof(uint8_t));
}

void bleInit() {
  Serial.println("Initiating the ble server!!!!");

  // Create the BLE Device
  BLEDevice::init("FM Server");

  BLEDevice::setEncryptionLevel(ESP_BLE_SEC_ENCRYPT_MITM);
  BLEDevice::setSecurityCallbacks(new MySecurity());

  pServer = BLEDevice::createServer();
  pServer->setCallbacks(new MyServerCallbacks());

  // Create the NUS BLE Service
  BLEService *pService = pServer->createService(SERVICE_UUID);

  // Create the BLE Characteristics (all properties added)
  pTxCharacteristic = pService->createCharacteristic(
      CHARACTERISTIC_UUID_TX,
      BLECharacteristic::PROPERTY_INDICATE
      );
    
  pTxCharacteristic->addDescriptor(new BLE2902());

  //pTxCharacteristic->setAccessPermissions(ESP_GATT_PERM_READ_ENCRYPTED);

  pRxCharacteristic = pService->createCharacteristic(
      CHARACTERISTIC_UUID_RX,
      BLECharacteristic::PROPERTY_WRITE);

  pRxCharacteristic->setAccessPermissions(ESP_GATT_PERM_WRITE_ENCRYPTED);

  pRxCharacteristic->setCallbacks(new MyCallbacks());

  // Start the service
  pService->start();

  advertise(pServer);

  // Set bonding requirement
  setupBonding();
}

void setup() {
  Serial.begin(9600);

  randomSeed(analogRead(0));

  bleInit();
}

int i = 0;

void handleMsg(QueueHandle_t msgQueue);

void loop() {
  if (deviceConnected && deviceBonded) {
    // read incoming messages
    // TODO: generalize to a specific protocol
    /*
       if (uxQueueMessagesWaiting(msgQueue) != 0) {
       handleMsg(msgQueue);
       } else {
       Serial.println("Sending msg: " + msg);      
       String msg = "Counter=" + String(i);

       pTxCharacteristic->setValue(msg);
       pTxCharacteristic->indicate();
       i+=1;
       }
       */
    if (uxQueueMessagesWaiting(msgQueue) > 0) {
      Serial.println("Handling message");
      handleMsg(msgQueue);
    }
  }

  if (!deviceConnected) {
    Serial.println("Device not connected: advertising");
    advertise(pServer);
  }

  int d=0;
  if (deviceConnected) {
    d=500;
  } else {
    d=2000;
  }
  delay(d);
}

void handleMsg(QueueHandle_t msgQueue) {
  String msg;
  xQueueReceive(msgQueue, &msg, portMAX_DELAY);
  // TODO: define a protocol to handle incoming messages
  String incoming_call_message = "incoming_call";
  String disconnect_message = "disconnect";
  if (msg.length() > 0) {
    Serial.println("*********");
    Serial.print("Received Value: ");
    if (msg==incoming_call_message) {
      Serial.println("INCOMING CALL!!!!");
    } else if(msg==disconnect_message) {
      Serial.println("Closing connection");
      deviceConnected=false;
    } else {
      size_t sz = msg.length();
      Serial.printf("printing message of size %d\n", sz);
      for (int i = 0; i < sz; i++) {
        Serial.print(msg[i]);
      }
      Serial.print("\n");
    }
    Serial.println("*********");
  }
}

void advertise(BLEServer* pServer) {
  BLEAdvertising* pAdvertising = pServer->getAdvertising();
  pAdvertising->addServiceUUID(SERVICE_UUID);
  pAdvertising->setScanResponse(true);
  // preferred minimum interval after which two devices exchange info
  pAdvertising->setMinPreferred(0x06);
  pAdvertising->setMinPreferred(0x12);
  pAdvertising->start();
}